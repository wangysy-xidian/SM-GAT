import json
import torch
import numpy as np
from torch_geometric.data import Data, Dataset
from tqdm import tqdm


class TrafficGraphDataset(Dataset):
    """
    PyTorch Geometric Dataset for Traffic Graphs.
    Loads preprocessed JSONL files containing structured graph data.
    """

    def __init__(self, jsonl_path, label_encoder=None, max_seq_len=50, fit_label=False):
        """
        Args:
            jsonl_path: Path to the .jsonl file generated by preprocess.py
            label_encoder: sklearn LabelEncoder instance
            max_seq_len: Maximum length for packet sequence truncation
            fit_label: Boolean, whether to fit the label encoder (True for training set)
        """
        super().__init__()
        self.data_list = []
        self.label_encoder = label_encoder
        self.max_seq_len = max_seq_len

        print(f"[*] Loading dataset from {jsonl_path}...")
        self._load_data(jsonl_path, fit_label)

    def _load_data(self, path, fit_label):
        raw_samples = []
        labels = []

        # 1. Read JSONL
        try:
            with open(path, 'r', encoding='utf-8') as f:
                for line in f:
                    entry = json.loads(line)
                    raw_samples.append(entry)
                    labels.append(entry['label'])
        except FileNotFoundError:
            print(f"[!] File not found: {path}")
            return

        # 2. Fit Label Encoder
        if fit_label and self.label_encoder is not None:
            self.label_encoder.fit(labels)
            print(f"[*] Classes fitted: {len(self.label_encoder.classes_)}")

        # 3. Convert to PyG Data
        for sample in tqdm(raw_samples, desc="Converting to Tensors"):
            graph_data = self._process_sample(sample)
            if graph_data:
                self.data_list.append(graph_data)

    def _process_sample(self, sample):
        """
        Converts a single structured dictionary sample into a PyG Data object.
        """
        try:
            nodes = sample['graph']['nodes']
            edges = sample['graph']['edges']
            label_str = sample['label']

            # --- A. Process Nodes ---
            seq_list = []
            stat_list = []
            time_list = []

            for node in nodes:
                # 1. Sequence Handling (Pad/Truncate)
                raw_seq = node['seq']
                if len(raw_seq) > self.max_seq_len:
                    seq_vec = raw_seq[:self.max_seq_len]
                else:
                    seq_vec = raw_seq + [0.0] * (self.max_seq_len - len(raw_seq))
                seq_list.append(seq_vec)

                # 2. Statistics Normalization (Log1p)
                # raw_stats: [Duration, BytesUp, BytesDown, Count, MeanIAT]
                raw_stats = node['stats']
                log_stats = np.log1p(raw_stats).tolist()
                stat_list.append(log_stats)

                time_list.append(node['t'])

            # Convert to Tensors
            x_seq = torch.tensor(seq_list, dtype=torch.float)
            x_stats = torch.tensor(stat_list, dtype=torch.float)
            node_times = np.array(time_list)

            # --- B. Process Edges ---
            if not edges:
                # Handle isolated nodes: Self-loops
                edge_index = torch.tensor([[0], [0]], dtype=torch.long)
                edge_attr = torch.tensor([[0, 0.0]], dtype=torch.float)
            else:
                src_list = []
                dst_list = []
                attr_list = []

                for u, v, e_type in edges:
                    src_list.append(u)
                    dst_list.append(v)

                    # Calculate Edge Time Difference (Delta T)
                    dt = abs(node_times[v] - node_times[u])
                    attr_list.append([float(e_type), float(dt)])

                edge_index = torch.tensor([src_list, dst_list], dtype=torch.long)
                edge_attr = torch.tensor(attr_list, dtype=torch.float)

            # --- C. Label ---
            if self.label_encoder:
                y = torch.tensor([self.label_encoder.transform([label_str])[0]], dtype=torch.long)
            else:
                # Placeholder if no encoder provided
                y = torch.tensor([-1], dtype=torch.long)

            return Data(
                x_seq=x_seq,
                x_stats=x_stats,
                edge_index=edge_index,
                edge_attr=edge_attr,
                y=y,
                num_nodes=len(nodes)
            )

        except Exception as e:
            # Silently skip malformed graphs or print debug info
            # print(f"Error processing sample: {e}")
            return None

    def len(self):
        return len(self.data_list)

    def get(self, idx):
        return self.data_list[idx]